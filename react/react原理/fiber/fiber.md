# fiber
 

## 一、fiber
 参考文章：[有react fiber，为什么不需要vue fiber呢？](https://juejin.cn/post/7077545184807878692)


### 1.1 出现的背景

  React16 引入了 fiber 架构

1. react视图更新流程是这样的：

* 组件渲染生成一棵新的虚拟dom树；
* 新旧虚拟dom树对比，找出变动的部分；（也就是常说的diff算法）
* 为真正改变的部分创建真实dom，把他们挂载到文档，实现页面重渲染；

2. 诞生原因

   react的数据更新去驱动视图更新的时候,存在需要diff的vdom树过大问题,比如我们都知道的react父组件数据更新会导致子组件一起更新问题就是体现。在数据更新时，react生成了一棵更大的虚拟dom树，给第二步的diff带来了很大压力——我们想找到真正变化的部分，这需要花费更长的时间。js占据主线程去做比较，渲染线程便无法做其他工作，用户的交互得不到响应，所以便出现了react fiber。

   详细：
   主流浏览器刷新频率为60Hz，即每（1000ms / 60Hz）16.6ms浏览器刷新一次
   JS可以操作DOM，GUI渲染线程与JS线程是互斥的。所以JS脚本执行和浏览器布局、绘制不能同时执行。
   在每16.6ms时间内，需要完成如下工作：
   >JS脚本执行 -----  样式布局 ----- 样式绘制
   当JS执行时间过长，超出了16.6ms，这次刷新就没有时间执行样式布局和样式绘制了，就会出现掉帧,造成卡顿

3. 作用
   react fiber没法让比较的时间缩短，但它使得diff的过程被分成一小段一小段的，因为它有了“保存工作进度”的能力。js会比较一部分虚拟dom，然后让渡主线程，给浏览器去做其他工作，然后继续比较，依次往复，等到最后比较完成，一次性更新到视图上。

### 1.2. 本质
原有的树结构
![Alt](./img/node.awebp)
fiber是一种新的数据结构
![Alt](./img/fiber-node.awebp)
在新的架构中，每个节点有三个指针：分别指向第一个子节点、下一个兄弟节点、父节点。这种数据结构就是fiber，它的遍历规则如下：

* 从根节点开始，依次遍历该节点的子节点、兄弟节点，如果两者都遍历了，则回到它的父节点；
* 当一个节点的所有子节点遍历完成，才认为该节点遍历完成；

 树和fiber虽然看起来很像，但本质上来说，一个是树，一个是链表。

### 1.3 纤程
这种数据结构之所以被叫做fiber，因为fiber的翻译是纤程，协程是比线程更小的调度单位：它的开启、暂停可以被程序员所控制。

那么后续就需要对fiber进行调度来控制他何时开始,暂停,

1. fiber的调度机制
具体来说，react fiber是通过requestIdleCallback这个api去控制的组件渲染的“进度条”。requesetIdleCallback是受屏幕的刷新率去控制。不做深入探讨，只需要知道它每隔16ms会被调用一次，它的回调函数可以获取本次可以执行的时间，每一个16ms除了requesetIdleCallback的回调之外，还有其他工作，所以能使用的时间是不确定的，但只要时间到了，就会停下节点的遍历。requestIdleCallback的回调函数可以通过传入的参数deadLine.timeRemaining()检查当下还有多少时间供自己使用。

 
但由于兼容性不好，加上该回调函数被调用的频率太低，react实际使用的是一个polyfill(自己实现的api)，而不是requestIdleCallback。

现在，可以总结一下了：React Fiber是React 16提出的一种更新机制，使用链表取代了树，将虚拟dom连接，使得组件更新的流程可以被中断恢复；它把组件渲染的工作分片，到时会主动让出渲染主线程。
 

 自己理解：
 1. fiber其实本质是只是一种数据结构,并不解决diff的vdom树过大的问题，他其实只是保证自己可以被暂停,状态保存和恢复 。另外有一套调度机制来控制fiber的暂停和开始。
 2. 为了保证不掉帧,就要保证在16.6ms内,能够查询到现在还有多少时间,时间足够,就可以继续进行diff,否则就要暂停,让渡出主线程来走渲染线程(用户响应)等,这样就可以避免掉帧



 
 


